{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\jowil\\\\Downloads\\\\rps_tfjs_demo-master\\\\rps_tfjs_demo-master\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\jowil\\\\Downloads\\\\rps_tfjs_demo-master\\\\rps_tfjs_demo-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\jowil\\\\Downloads\\\\rps_tfjs_demo-master\\\\rps_tfjs_demo-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\jowil\\\\Downloads\\\\rps_tfjs_demo-master\\\\rps_tfjs_demo-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\jowil\\\\Downloads\\\\rps_tfjs_demo-master\\\\rps_tfjs_demo-master\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport * as tf from '@tensorflow/tfjs';\nimport { IMAGE_SIZE, NUM_CLASSES, NUM_DATASET_ELEMENTS, NUM_CHANNELS, BYTES_PER_UINT8, NUM_TRAIN_ELEMENTS, NUM_TEST_ELEMENTS } from './constants';\nvar RPS_IMAGES_SPRITE_PATH = '/data.png';\nvar RPS_LABELS_PATH = '/labels_uint8';\nexport var RPSDataset =\n/*#__PURE__*/\nfunction () {\n  function RPSDataset() {\n    _classCallCheck(this, RPSDataset);\n\n    this.shuffledTrainIndex = 0;\n    this.shuffledTestIndex = 0;\n  }\n\n  _createClass(RPSDataset, [{\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var img, canvas, ctx, imgRequest, labelsRequest, _ref, _ref2, _imgResponse, labelsResponse;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Make a request for the RPS sprited image.\n                img = new Image();\n                canvas = document.createElement('canvas');\n                ctx = canvas.getContext('2d'); // Load full dataset sprite\n\n                imgRequest = new Promise(function (resolve, _reject) {\n                  img.crossOrigin = '';\n\n                  img.onload = function () {\n                    img.width = img.naturalWidth;\n                    img.height = img.naturalHeight; // Every possible pixel and value\n\n                    var datasetBytesBuffer = new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE * BYTES_PER_UINT8 * NUM_CHANNELS // * 4 because number of bytes\n                    ); // Chunk size: ratio of Test set size (tweak as needed)\n\n                    var chunkSize = Math.floor(NUM_TEST_ELEMENTS * 0.15);\n                    canvas.width = img.width;\n                    canvas.height = chunkSize; // Read in images in chunkSize for speed\n\n                    for (var i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {\n                      var datasetBytesView = new Float32Array(datasetBytesBuffer, // buffer\n                      i * chunkSize * IMAGE_SIZE * BYTES_PER_UINT8 * NUM_CHANNELS, // byteOffset * 4 because RGBA format\n                      IMAGE_SIZE * chunkSize * NUM_CHANNELS // length\n                      );\n                      ctx.drawImage(img, 0, i * chunkSize, img.width, chunkSize, 0, 0, img.width, chunkSize); // RGBA of image pixels (0-255)\n\n                      var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                      var x = 0; // Jumps by 4 storing RGBA\n\n                      for (var j = 0; j < imageData.data.length; j += 4) {\n                        // Stores R, then G, then B, then A\n                        for (var _i = 0; _i < NUM_CHANNELS; _i++) {\n                          datasetBytesView[x++] = imageData.data[j + _i] / 255;\n                        }\n                      }\n                    }\n\n                    _this.datasetImages = new Float32Array(datasetBytesBuffer);\n                    resolve();\n                  };\n\n                  img.src = RPS_IMAGES_SPRITE_PATH;\n                });\n                labelsRequest = fetch(RPS_LABELS_PATH);\n                _context.next = 7;\n                return Promise.all([imgRequest, labelsRequest]);\n\n              case 7:\n                _ref = _context.sent;\n                _ref2 = _slicedToArray(_ref, 2);\n                _imgResponse = _ref2[0];\n                labelsResponse = _ref2[1];\n                _context.t0 = Uint8Array;\n                _context.next = 14;\n                return labelsResponse.arrayBuffer();\n\n              case 14:\n                _context.t1 = _context.sent;\n                this.datasetLabels = new _context.t0(_context.t1);\n                // Create shuffled indices into the train/test set for when we select a\n                // random dataset element for training / validation.\n                this.trainIndices = tf.util.createShuffledIndices(NUM_TRAIN_ELEMENTS);\n                this.testIndices = tf.util.createShuffledIndices(NUM_TEST_ELEMENTS); // Slice the the images and labels into train and test sets.\n                // This style of slicing hopes that they have been randomized BEFORE\n                // they show up here.  Otherwise your test set might be all the same class\n                // UGH!  I guess double randomization is fine.\n\n                this.trainImages = this.datasetImages.slice(0, IMAGE_SIZE * NUM_TRAIN_ELEMENTS * NUM_CHANNELS);\n                this.testImages = this.datasetImages.slice(IMAGE_SIZE * NUM_TRAIN_ELEMENTS * NUM_CHANNELS);\n                this.trainLabels = this.datasetLabels.slice(0, NUM_CLASSES * NUM_TRAIN_ELEMENTS);\n                this.testLabels = this.datasetLabels.slice(NUM_CLASSES * NUM_TRAIN_ELEMENTS);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"nextTrainBatch\",\n    value: function nextTrainBatch(batchSize) {\n      var _this2 = this;\n\n      return this.nextBatch(batchSize, [this.trainImages, this.trainLabels], function () {\n        _this2.shuffledTrainIndex = (_this2.shuffledTrainIndex + 1) % _this2.trainIndices.length;\n        return _this2.trainIndices[_this2.shuffledTrainIndex]; // return this.shuffledTrainIndex // For debugging, no rando\n      });\n    }\n  }, {\n    key: \"nextTestBatch\",\n    value: function nextTestBatch(batchSize) {\n      var _this3 = this;\n\n      return this.nextBatch(batchSize, [this.testImages, this.testLabels], function () {\n        _this3.shuffledTestIndex = (_this3.shuffledTestIndex + 1) % _this3.testIndices.length;\n        return _this3.testIndices[_this3.shuffledTestIndex]; // return this.shuffledTestIndex // For debugging, no rando\n      });\n    }\n  }, {\n    key: \"nextBatch\",\n    value: function nextBatch(batchSize, data, index) {\n      var batchImagesArray = new Float32Array(batchSize * IMAGE_SIZE * NUM_CHANNELS);\n      var batchLabelsArray = new Uint8Array(batchSize * NUM_CLASSES); // Create a batchSize of images\n\n      for (var i = 0; i < batchSize; i++) {\n        var idx = index();\n        var startPoint = idx * IMAGE_SIZE * NUM_CHANNELS;\n        var image = data[0].slice(startPoint, startPoint + IMAGE_SIZE * NUM_CHANNELS);\n        batchImagesArray.set(image, i * IMAGE_SIZE * NUM_CHANNELS);\n        var label = data[1].slice(idx * NUM_CLASSES, idx * NUM_CLASSES + NUM_CLASSES);\n        batchLabelsArray.set(label, i * NUM_CLASSES);\n      }\n\n      var xs = tf.tensor3d(batchImagesArray, [batchSize, IMAGE_SIZE, NUM_CHANNELS]);\n      var labels = tf.tensor2d(batchLabelsArray, [batchSize, NUM_CLASSES]);\n      return {\n        xs: xs,\n        labels: labels\n      };\n    }\n  }]);\n\n  return RPSDataset;\n}();","map":{"version":3,"sources":["C:/Users/jowil/Downloads/rps_tfjs_demo-master/rps_tfjs_demo-master/src/tfjs/data.js"],"names":["tf","IMAGE_SIZE","NUM_CLASSES","NUM_DATASET_ELEMENTS","NUM_CHANNELS","BYTES_PER_UINT8","NUM_TRAIN_ELEMENTS","NUM_TEST_ELEMENTS","RPS_IMAGES_SPRITE_PATH","RPS_LABELS_PATH","RPSDataset","shuffledTrainIndex","shuffledTestIndex","img","Image","canvas","document","createElement","ctx","getContext","imgRequest","Promise","resolve","_reject","crossOrigin","onload","width","naturalWidth","height","naturalHeight","datasetBytesBuffer","ArrayBuffer","chunkSize","Math","floor","i","datasetBytesView","Float32Array","drawImage","imageData","getImageData","x","j","data","length","datasetImages","src","labelsRequest","fetch","all","_imgResponse","labelsResponse","Uint8Array","arrayBuffer","datasetLabels","trainIndices","util","createShuffledIndices","testIndices","trainImages","slice","testImages","trainLabels","testLabels","batchSize","nextBatch","index","batchImagesArray","batchLabelsArray","idx","startPoint","image","set","label","xs","tensor3d","labels","tensor2d"],"mappings":"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","sourcesContent":["import * as tf from '@tensorflow/tfjs'\nimport {\n  IMAGE_SIZE,\n  NUM_CLASSES,\n  NUM_DATASET_ELEMENTS,\n  NUM_CHANNELS,\n  BYTES_PER_UINT8,\n  NUM_TRAIN_ELEMENTS,\n  NUM_TEST_ELEMENTS\n} from './constants'\n\nconst RPS_IMAGES_SPRITE_PATH = '/data.png'\nconst RPS_LABELS_PATH = '/labels_uint8'\n\nexport class RPSDataset {\n  constructor() {\n    this.shuffledTrainIndex = 0\n    this.shuffledTestIndex = 0\n  }\n\n  async load() {\n    // Make a request for the RPS sprited image.\n    const img = new Image()\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    // Load full dataset sprite\n    const imgRequest = new Promise((resolve, _reject) => {\n      img.crossOrigin = ''\n      img.onload = () => {\n        img.width = img.naturalWidth\n        img.height = img.naturalHeight\n\n        // Every possible pixel and value\n        const datasetBytesBuffer = new ArrayBuffer(\n          NUM_DATASET_ELEMENTS * IMAGE_SIZE * BYTES_PER_UINT8 * NUM_CHANNELS // * 4 because number of bytes\n        )\n\n        // Chunk size: ratio of Test set size (tweak as needed)\n        const chunkSize = Math.floor(NUM_TEST_ELEMENTS * 0.15)\n        canvas.width = img.width\n        canvas.height = chunkSize\n\n        // Read in images in chunkSize for speed\n        for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {\n          const datasetBytesView = new Float32Array(\n            datasetBytesBuffer, // buffer\n            i * chunkSize * IMAGE_SIZE * BYTES_PER_UINT8 * NUM_CHANNELS, // byteOffset * 4 because RGBA format\n            IMAGE_SIZE * chunkSize * NUM_CHANNELS // length\n          )\n          ctx.drawImage(\n            img,\n            0,\n            i * chunkSize,\n            img.width,\n            chunkSize,\n            0,\n            0,\n            img.width,\n            chunkSize\n          )\n\n          // RGBA of image pixels (0-255)\n          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n          let x = 0\n          // Jumps by 4 storing RGBA\n          for (let j = 0; j < imageData.data.length; j += 4) {\n            // Stores R, then G, then B, then A\n            for (let i = 0; i < NUM_CHANNELS; i++) {\n              datasetBytesView[x++] = imageData.data[j + i] / 255\n            }\n          }\n        }\n        this.datasetImages = new Float32Array(datasetBytesBuffer)\n        resolve()\n      }\n      img.src = RPS_IMAGES_SPRITE_PATH\n    })\n\n    const labelsRequest = fetch(RPS_LABELS_PATH)\n    const [_imgResponse, labelsResponse] = await Promise.all([\n      imgRequest,\n      labelsRequest\n    ])\n\n    this.datasetLabels = new Uint8Array(await labelsResponse.arrayBuffer())\n\n    // Create shuffled indices into the train/test set for when we select a\n    // random dataset element for training / validation.\n    this.trainIndices = tf.util.createShuffledIndices(NUM_TRAIN_ELEMENTS)\n    this.testIndices = tf.util.createShuffledIndices(NUM_TEST_ELEMENTS)\n\n    // Slice the the images and labels into train and test sets.\n    // This style of slicing hopes that they have been randomized BEFORE\n    // they show up here.  Otherwise your test set might be all the same class\n    // UGH!  I guess double randomization is fine.\n    this.trainImages = this.datasetImages.slice(\n      0,\n      IMAGE_SIZE * NUM_TRAIN_ELEMENTS * NUM_CHANNELS\n    )\n    this.testImages = this.datasetImages.slice(\n      IMAGE_SIZE * NUM_TRAIN_ELEMENTS * NUM_CHANNELS\n    )\n    this.trainLabels = this.datasetLabels.slice(\n      0,\n      NUM_CLASSES * NUM_TRAIN_ELEMENTS\n    )\n    this.testLabels = this.datasetLabels.slice(NUM_CLASSES * NUM_TRAIN_ELEMENTS)\n  }\n\n  nextTrainBatch(batchSize) {\n    return this.nextBatch(\n      batchSize,\n      [this.trainImages, this.trainLabels],\n      () => {\n        this.shuffledTrainIndex =\n          (this.shuffledTrainIndex + 1) % this.trainIndices.length\n        return this.trainIndices[this.shuffledTrainIndex]\n        // return this.shuffledTrainIndex // For debugging, no rando\n      }\n    )\n  }\n\n  nextTestBatch(batchSize) {\n    return this.nextBatch(batchSize, [this.testImages, this.testLabels], () => {\n      this.shuffledTestIndex =\n        (this.shuffledTestIndex + 1) % this.testIndices.length\n      return this.testIndices[this.shuffledTestIndex]\n      // return this.shuffledTestIndex // For debugging, no rando\n    })\n  }\n\n  nextBatch(batchSize, data, index) {\n    const batchImagesArray = new Float32Array(\n      batchSize * IMAGE_SIZE * NUM_CHANNELS\n    )\n    const batchLabelsArray = new Uint8Array(batchSize * NUM_CLASSES)\n\n    // Create a batchSize of images\n    for (let i = 0; i < batchSize; i++) {\n      const idx = index()\n\n      const startPoint = idx * IMAGE_SIZE * NUM_CHANNELS\n      const image = data[0].slice(\n        startPoint,\n        startPoint + IMAGE_SIZE * NUM_CHANNELS\n      )\n      batchImagesArray.set(image, i * IMAGE_SIZE * NUM_CHANNELS)\n\n      const label = data[1].slice(\n        idx * NUM_CLASSES,\n        idx * NUM_CLASSES + NUM_CLASSES\n      )\n      batchLabelsArray.set(label, i * NUM_CLASSES)\n    }\n    const xs = tf.tensor3d(batchImagesArray, [\n      batchSize,\n      IMAGE_SIZE,\n      NUM_CHANNELS\n    ])\n    const labels = tf.tensor2d(batchLabelsArray, [batchSize, NUM_CLASSES])\n    return { xs, labels }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}