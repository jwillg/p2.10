{"ast":null,"code":"import _defineProperty from \"C:\\\\git\\\\p2.10\\\\rps_demo\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\git\\\\p2.10\\\\rps_demo\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { SCALE_CHANNELS, X, X2, Y2 } from '../../channel';\nimport { getTypedFieldDef, isConditionalSelection, isFieldDef, isValueDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { VG_MARK_CONFIGS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyleConfig } from '../common';\nimport { expression } from '../predicate';\nimport { parseSelectionPredicate } from '../selection/parse';\nimport * as ref from './valueref';\nimport { fieldInvalidPredicate } from './valueref';\nexport function color(model) {\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var filled = markDef.filled,\n      markType = markDef.type;\n  var configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n  var transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType) ? 'transparent' : undefined;\n  var defaultFill = getFirstDefined(markDef.fill, filled === true ? markDef.color : undefined, configValue.fill, filled === true ? configValue.color : undefined, // If there is no fill, always fill symbols, bar, geoshape\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  transparentIfNeeded);\n  var defaultStroke = getFirstDefined(markDef.stroke, filled === false ? markDef.color : undefined, configValue.stroke, filled === false ? configValue.color : undefined);\n  var colorVgChannel = filled ? 'fill' : 'stroke';\n  var fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? {\n    fill: {\n      value: defaultFill\n    }\n  } : {}), defaultStroke ? {\n    stroke: {\n      value: defaultStroke\n    }\n  } : {});\n\n  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n    log.warn(log.message.droppingColor('property', {\n      fill: 'fill' in markDef,\n      stroke: 'stroke' in markDef\n    }));\n  }\n\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n    vgChannel: colorVgChannel,\n    defaultValue: filled ? defaultFill : defaultStroke\n  })), nonPosition('fill', model, {\n    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n    defaultValue: encoding.fill ? defaultFill : undefined\n  })), nonPosition('stroke', model, {\n    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n    defaultValue: encoding.stroke ? defaultStroke : undefined\n  }));\n}\nexport function baseEncodeEntry(model, ignore) {\n  var _ref = ignore.color === 'include' ? color(model) : {},\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? undefined : _ref$fill,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? undefined : _ref$stroke;\n\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), tooltip(model)), text(model, 'href'));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  var config = model.config,\n      mark = model.mark,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    var test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return _defineProperty({}, channel, [// prepend the invalid case\n      // TODO: support custom value\n      {\n        test: test,\n        value: null\n      }].concat(_toConsumableArray(array(valueRef))));\n    }\n  }\n\n  return valueRef ? _defineProperty({}, channel, valueRef) : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce(function (m, prop) {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {\n        value: mark[prop]\n      };\n    }\n\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return _defineProperty({}, prop, {\n      value: value\n    });\n  }\n\n  return undefined;\n}\n\nfunction allFieldsInvalidPredicate(model, _ref5) {\n  var _ref5$invalid = _ref5.invalid,\n      invalid = _ref5$invalid === void 0 ? false : _ref5$invalid,\n      channels = _ref5.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}\n\nexport function defined(model) {\n  var config = model.config,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    var signal = allFieldsInvalidPredicate(model, {\n      channels: ['x', 'y']\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal: signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n/**\n * Return mixins for non-positional channels with scales. (Text doesn't have scale.)\n */\n\nexport function nonPosition(channel, model) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var _opt$vgChannel = opt.vgChannel,\n      vgChannel = _opt$vgChannel === void 0 ? channel : _opt$vgChannel;\n  var defaultRef = opt.defaultRef,\n      defaultValue = opt.defaultValue;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : vgChannel === channel ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n    markDef[channel] : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n    getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {\n      vgChannel: vgChannel\n    }));\n    defaultRef = defaultValue ? {\n      value: defaultValue\n    } : undefined;\n  }\n\n  var channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel, function (cDef) {\n    return ref.midPoint({\n      channel: channel,\n      channelDef: cDef,\n      markDef: markDef,\n      config: config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef: defaultRef\n    });\n  });\n}\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  var condition = channelDef && channelDef.condition;\n  var valueRef = refFn(channelDef);\n\n  if (condition) {\n    var conditions = array(condition);\n    var vgConditions = conditions.map(function (c) {\n      var conditionValueRef = refFn(c);\n      var test = isConditionalSelection(c) ? parseSelectionPredicate(model, c.selection) : expression(model, c.test);\n      return Object.assign({\n        test: test\n      }, conditionValueRef);\n    });\n    return _defineProperty({}, vgChannel, [].concat(_toConsumableArray(vgConditions), _toConsumableArray(valueRef !== undefined ? [valueRef] : [])));\n  } else {\n    return valueRef !== undefined ? _defineProperty({}, vgChannel, valueRef) : {};\n  }\n}\nexport function tooltip(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = model.encoding,\n      markDef = model.markDef,\n      config = model.config;\n  var channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: ref.tooltipForEncoding({\n        tooltip: channelDef\n      }, config, opt)\n    };\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', function (cDef) {\n      // use valueRef based on channelDef first\n      var tooltipRefFromChannelDef = ref.text(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      } // If tooltipDef does not exist, then use value from markDef or config\n\n\n      var markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return ref.tooltipForEncoding(encoding, config, opt);\n        } else {\n          return {\n            signal: 'datum'\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function text(model) {\n  var channel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n  var channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, function (cDef) {\n    return ref.text(cDef, model.config);\n  });\n}\nexport function bandPosition(fieldDef, channel, model, defaultSizeRef) {\n  var _ref8;\n\n  var _a;\n\n  var scaleName = model.scaleName(channel);\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (model.encoding.size != null || model.markDef.size != null || ((_a = defaultSizeRef) === null || _a === void 0 ? void 0 : _a.value) !== undefined) {\n    var orient = model.markDef.orient;\n\n    if (orient) {\n      var centeredBandPositionMixins = _defineProperty({}, channel + 'c', ref.fieldRef(fieldDef, scaleName, {}, {\n        band: 0.5\n      }));\n\n      if (getTypedFieldDef(model.encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (isValueDef(model.encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (model.markDef.size !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), _defineProperty({}, sizeChannel, {\n          value: model.markDef.size\n        }));\n      } else if (defaultSizeRef && defaultSizeRef.value !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), _defineProperty({}, sizeChannel, defaultSizeRef));\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n\n  var _fieldDef$band = fieldDef.band,\n      band = _fieldDef$band === void 0 ? 1 : _fieldDef$band;\n  return _ref8 = {}, _defineProperty(_ref8, channel, ref.fieldRef(fieldDef, scaleName, {\n    binSuffix: 'range'\n  }, {\n    band: (1 - band) / 2\n  })), _defineProperty(_ref8, sizeChannel, defaultSizeRef !== null && defaultSizeRef !== void 0 ? defaultSizeRef : ref.bandRef(scaleName, band)), _ref8;\n}\nexport function centeredPointPositionWithSize(channel, model, defaultPosRef, defaultSizeRef) {\n  var centerChannel = channel === 'x' ? 'xc' : 'yc';\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  return Object.assign(Object.assign({}, pointPosition(channel, model, defaultPosRef, {\n    vgChannel: centerChannel\n  })), nonPosition('size', model, {\n    defaultRef: defaultSizeRef,\n    vgChannel: sizeChannel\n  }));\n}\nexport function binPosition(_ref9) {\n  var fieldDef = _ref9.fieldDef,\n      fieldDef2 = _ref9.fieldDef2,\n      channel = _ref9.channel,\n      band = _ref9.band,\n      scaleName = _ref9.scaleName,\n      markDef = _ref9.markDef,\n      _ref9$spacing = _ref9.spacing,\n      spacing = _ref9$spacing === void 0 ? 0 : _ref9$spacing,\n      reverse = _ref9.reverse;\n  var binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  var channel2 = channel === X ? X2 : Y2;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    var _ref10;\n\n    return _ref10 = {}, _defineProperty(_ref10, channel2, ref.bin({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: (1 - band) / 2,\n      offset: binSpacing[\"\".concat(channel, \"2\")]\n    })), _defineProperty(_ref10, channel, ref.bin({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: 1 - (1 - band) / 2,\n      offset: binSpacing[channel]\n    })), _ref10;\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    var _ref11;\n\n    return _ref11 = {}, _defineProperty(_ref11, channel2, ref.fieldRef(fieldDef, scaleName, {}, {\n      offset: binSpacing[\"\".concat(channel, \"2\")]\n    })), _defineProperty(_ref11, channel, ref.fieldRef(fieldDef2, scaleName, {}, {\n      offset: binSpacing[channel]\n    })), _ref11;\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n/**\n * Return mixins for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, defaultRef) {\n  var _ref12 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      vgChannel = _ref12.vgChannel;\n\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef,\n      config = model.config,\n      stack = model.stack;\n  var channelDef = encoding[channel];\n  var channel2Def = encoding[channel === X ? X2 : Y2];\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var offset = ref.getOffset(channel, model.markDef);\n  var valueRef = !channelDef && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : ref.position({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: channel2Def,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: ref.positionDefault({\n      markDef: markDef,\n      config: config,\n      defaultRef: defaultRef,\n      channel: channel,\n      scaleName: scaleName,\n      scale: scale,\n      mark: mark,\n      checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n\n    })\n  });\n  return _defineProperty({}, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, valueRef);\n}\nvar ALIGNED_X_CHANNEL = {\n  left: 'x',\n  center: 'xc',\n  right: 'x2'\n};\nvar BASELINED_Y_CHANNEL = {\n  top: 'y',\n  middle: 'yc',\n  bottom: 'y2'\n};\nexport function pointOrRangePosition(channel, model, _ref14) {\n  var defaultRef = _ref14.defaultRef,\n      defaultRef2 = _ref14.defaultRef2,\n      range = _ref14.range;\n\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultRef: defaultRef,\n      defaultRef2: defaultRef2\n    });\n  }\n\n  return pointPosition(channel, model, defaultRef);\n}\nexport function rangePosition(channel, model, _ref15) {\n  var defaultRef = _ref15.defaultRef,\n      defaultRef2 = _ref15.defaultRef2;\n  var markDef = model.markDef,\n      config = model.config;\n  var channel2 = channel === 'x' ? 'x2' : 'y2';\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  var pos2Mixins = pointPosition2(model, defaultRef2, channel2);\n  var vgChannel = pos2Mixins[sizeChannel] ? alignedChannel(channel, markDef, config) : channel;\n  return Object.assign(Object.assign({}, pointPosition(channel, model, defaultRef, {\n    vgChannel: vgChannel\n  })), pos2Mixins);\n}\n\nfunction alignedChannel(channel, markDef, config) {\n  var alignChannel = channel === 'x' ? 'align' : 'baseline';\n  var align = getFirstDefined(markDef[alignChannel], getMarkConfig(alignChannel, markDef, config));\n\n  if (channel === 'x') {\n    return ALIGNED_X_CHANNEL[align !== null && align !== void 0 ? align : 'center'];\n  } else {\n    return BASELINED_Y_CHANNEL[align !== null && align !== void 0 ? align : 'middle'];\n  }\n}\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\n\nfunction pointPosition2(model, defaultRef, channel) {\n  var _position2orSize;\n\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef,\n      stack = model.stack,\n      config = model.config;\n  var baseChannel = channel === 'x2' ? 'x' : 'y';\n  var sizeChannel = channel === 'x2' ? 'width' : 'height';\n  var channelDef = encoding[baseChannel];\n  var scaleName = model.scaleName(baseChannel);\n  var scale = model.getScaleComponent(baseChannel);\n  var offset = ref.getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return _defineProperty({}, channel, {\n      field: model.getName(channel)\n    });\n  }\n\n  var valueRef = ref.position2({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: encoding[channel],\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return _defineProperty({}, channel, valueRef);\n  } // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n\n  return getFirstDefined(position2orSize(channel, markDef), position2orSize(channel, (_position2orSize = {}, _defineProperty(_position2orSize, channel, getStyleConfig(channel, markDef, config.style)), _defineProperty(_position2orSize, sizeChannel, getStyleConfig(sizeChannel, markDef, config.style)), _position2orSize)), position2orSize(channel, config[mark]), position2orSize(channel, config.mark), _defineProperty({}, channel, ref.positionDefault({\n    markDef: markDef,\n    config: config,\n    defaultRef: defaultRef,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale,\n    mark: mark,\n    checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n\n  })()));\n}\n\nfunction position2orSize(channel, markDef) {\n  var sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  if (markDef[channel]) {\n    return _defineProperty({}, channel, ref.vgValueRef(channel, markDef[channel]));\n  } else if (markDef[sizeChannel]) {\n    return _defineProperty({}, sizeChannel, {\n      value: markDef[sizeChannel]\n    });\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}