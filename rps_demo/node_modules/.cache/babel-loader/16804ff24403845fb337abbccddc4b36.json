{"ast":null,"code":"import { array } from 'vega-util';\nimport { isFunction, isString, stringValue } from 'vega-util';\nimport { isCountingAggregateOp } from '../../aggregate';\nimport { isBinned, isBinning } from '../../bin';\nimport { getMainRangeChannel, X, X2, Y, Y2 } from '../../channel';\nimport { binRequiresRange, format, getBand, getFieldDef, hasConditionalFieldDef, isFieldDef, isPositionFieldDef, isTypedFieldDef, isValueDef, title, vgField } from '../../channeldef';\nimport { forEach } from '../../encoding';\nimport * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { fieldValidPredicate } from '../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous, ScaleType } from '../../scale';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { binFormatExpression, formatSignalRef, getMarkConfig } from '../common';\n\nfunction midPointWithPositionInvalidTest(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      markDef = params.markDef,\n      scale = params.scale;\n  var ref = midPoint(params); // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n\n  if ( // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n  scale && isContinuousToContinuous(scale.get('type')) && scale.get('zero') === false) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel: channel,\n      markDef: markDef,\n      ref: ref\n    });\n  }\n\n  return ref;\n}\n\nfunction wrapPositionInvalidTest(_ref) {\n  var fieldDef = _ref.fieldDef,\n      channel = _ref.channel,\n      markDef = _ref.markDef,\n      ref = _ref.ref;\n\n  if (!isPathMark(markDef.type)) {\n    // Only do this for non-path mark (as path marks will already use \"defined\" to skip points)\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n\n  return ref;\n}\n\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  var test = fieldInvalidPredicate(fieldDef, true);\n  var mainChannel = getMainRangeChannel(channel);\n  var zeroValueRef = mainChannel === 'x' ? {\n    value: 0\n  } : {\n    field: {\n      group: 'height'\n    }\n  };\n  return Object.assign({\n    test: test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field) {\n  var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nexport function position(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      scaleName = params.scaleName,\n      stack = params.stack,\n      offset = params.offset;\n\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return interpolatedPositionSignal({\n        scaleName: scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return fieldRef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset: offset\n    });\n  }\n\n  return midPointWithPositionInvalidTest(params);\n}\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\n\nexport function position2(_ref2) {\n  var channel = _ref2.channel,\n      channelDef = _ref2.channelDef,\n      channel2Def = _ref2.channel2Def,\n      markDef = _ref2.markDef,\n      config = _ref2.config,\n      scaleName = _ref2.scaleName,\n      scale = _ref2.scale,\n      stack = _ref2.stack,\n      offset = _ref2.offset,\n      defaultRef = _ref2.defaultRef;\n\n  if (isFieldDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return fieldRef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset: offset\n    });\n  }\n\n  return midPointWithPositionInvalidTest({\n    channel: channel,\n    channelDef: channel2Def,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    markDef: markDef,\n    config: config,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n}\nexport function getOffset(channel, markDef) {\n  var offsetChannel = channel + 'Offset'; // Need to cast as the type can't be inferred automatically\n  // TODO: in the future read from encoding channel too\n\n  var markDefOffsetValue = markDef[offsetChannel];\n\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function bin(_ref3) {\n  var channel = _ref3.channel,\n      fieldDef = _ref3.fieldDef,\n      scaleName = _ref3.scaleName,\n      markDef = _ref3.markDef,\n      band = _ref3.band,\n      offset = _ref3.offset;\n  var ref = interpolatedPositionSignal({\n    scaleName: scaleName,\n    fieldDef: fieldDef,\n    band: band,\n    offset: offset\n  });\n  return wrapPositionInvalidTest({\n    fieldDef: fieldDef,\n    channel: channel,\n    markDef: markDef,\n    ref: ref\n  });\n}\nexport function fieldRef(fieldDef, scaleName, opt, mixins) {\n  var ref = Object.assign(Object.assign({}, scaleName ? {\n    scale: scaleName\n  } : {}), {\n    field: vgField(fieldDef, opt)\n  });\n\n  if (mixins) {\n    var offset = mixins.offset,\n        band = mixins.band;\n    return Object.assign(Object.assign(Object.assign({}, ref), offset ? {\n      offset: offset\n    } : {}), band ? {\n      band: band\n    } : {});\n  }\n\n  return ref;\n}\nexport function bandRef(scaleName) {\n  var band = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\n\nfunction interpolatedPositionSignal(_ref4) {\n  var scaleName = _ref4.scaleName,\n      fieldDef = _ref4.fieldDef,\n      fieldDef2 = _ref4.fieldDef2,\n      offset = _ref4.offset,\n      startSuffix = _ref4.startSuffix,\n      _ref4$band = _ref4.band,\n      band = _ref4$band === void 0 ? 0.5 : _ref4$band;\n  var expr = 0 < band && band < 1 ? 'datum' : undefined;\n  var start = vgField(fieldDef, {\n    expr: expr,\n    suffix: startSuffix\n  });\n  var end = fieldDef2 !== undefined ? vgField(fieldDef2, {\n    expr: expr\n  }) : vgField(fieldDef, {\n    suffix: 'end',\n    expr: expr\n  });\n\n  if (band === 0) {\n    return Object.assign({\n      scale: scaleName,\n      field: start\n    }, offset ? {\n      offset: offset\n    } : {});\n  } else if (band === 1) {\n    return Object.assign({\n      scale: scaleName,\n      field: end\n    }, offset ? {\n      offset: offset\n    } : {});\n  } else {\n    var datum = \"\".concat(band, \" * \").concat(start, \" + \").concat(1 - band, \" * \").concat(end);\n    return Object.assign({\n      signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(datum, \")\")\n    }, offset ? {\n      offset: offset\n    } : {});\n  }\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\n\n\nexport function midPoint(_ref5) {\n  var channel = _ref5.channel,\n      channelDef = _ref5.channelDef,\n      channel2Def = _ref5.channel2Def,\n      markDef = _ref5.markDef,\n      config = _ref5.config,\n      scaleName = _ref5.scaleName,\n      scale = _ref5.scale,\n      stack = _ref5.stack,\n      offset = _ref5.offset,\n      defaultRef = _ref5.defaultRef;\n\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        var band = getBand(channel, channelDef, channel2Def, markDef, config, {\n          isMidPoint: true\n        });\n\n        if (isBinning(channelDef.bin) || band && channelDef.timeUnit) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (contains([X, Y], channel) && contains([QUANTITATIVE, TEMPORAL], channelDef.type)) {\n            if (stack && stack.impute) {\n              // For stack, we computed bin_mid so we can impute.\n              return fieldRef(channelDef, scaleName, {\n                binSuffix: 'mid'\n              }, {\n                offset: offset\n              });\n            } // For non-stack, we can just calculate bin mid on the fly using signal.\n\n\n            return interpolatedPositionSignal({\n              scaleName: scaleName,\n              fieldDef: channelDef,\n              band: band,\n              offset: offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset: offset\n          });\n        } else if (isBinned(channelDef.bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedPositionSignal({\n              scaleName: scaleName,\n              fieldDef: channelDef,\n              fieldDef2: channel2Def,\n              band: band,\n              offset: offset\n            });\n          } else {\n            var channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      if (scale) {\n        var scaleType = scale.get('type');\n\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            var _band = getFirstDefined(isPositionFieldDef(channelDef) ? channelDef.band : undefined, 0.5);\n\n            return fieldRef(channelDef, scaleName, {\n              binSuffix: 'range'\n            }, {\n              band: _band,\n              offset: offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, {\n            binSuffix: 'range'\n          }, {\n            offset: offset\n          });\n        }\n      }\n\n      return fieldRef(channelDef, scaleName, {}, {\n        offset: offset\n      }); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      var value = channelDef.value;\n      var offsetMixins = offset ? {\n        offset: offset\n      } : {};\n      return Object.assign(Object.assign({}, vgValueRef(channel, value)), offsetMixins);\n    } // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\n\nexport function vgValueRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n\n  return {\n    value: value\n  };\n}\nexport function tooltipForEncoding(encoding, config) {\n  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      reactiveGeom = _ref6.reactiveGeom;\n\n  var keyValues = [];\n  var usedKey = {};\n  var toSkip = {};\n  var expr = reactiveGeom ? 'datum.datum' : 'datum';\n  var tooltipTuples = [];\n\n  function add(fDef, channel) {\n    var mainChannel = getMainRangeChannel(channel);\n    var fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    var key = array(title(fieldDef, config, {\n      allowDisabling: false\n    })).join(', ');\n    var value = text(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      var channel2 = channel === 'x' ? 'x2' : 'y2';\n      var fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        var startField = vgField(fieldDef, {\n          expr: expr\n        });\n        var endField = vgField(fieldDef2, {\n          expr: expr\n        });\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({\n      channel: channel,\n      key: key,\n      value: value\n    });\n  }\n\n  forEach(encoding, function (channelDef, channel) {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (var _i = 0, _tooltipTuples = tooltipTuples; _i < _tooltipTuples.length; _i++) {\n    var _tooltipTuples$_i = _tooltipTuples[_i],\n        channel = _tooltipTuples$_i.channel,\n        key = _tooltipTuples$_i.key,\n        value = _tooltipTuples$_i.value;\n\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(\"\".concat(stringValue(key), \": \").concat(value));\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length ? {\n    signal: \"{\".concat(keyValues.join(', '), \"}\")\n  } : undefined;\n}\nexport function text(channelDef, config) {\n  var expr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'datum';\n\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {\n        value: channelDef.value\n      };\n    }\n\n    if (isTypedFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), expr, config);\n    }\n  }\n\n  return undefined;\n}\nexport function mid(sizeRef) {\n  return Object.assign(Object.assign({}, sizeRef), {\n    mult: 0.5\n  });\n}\nexport function positionDefault(_ref7) {\n  var markDef = _ref7.markDef,\n      config = _ref7.config,\n      defaultRef = _ref7.defaultRef,\n      channel = _ref7.channel,\n      scaleName = _ref7.scaleName,\n      scale = _ref7.scale,\n      mark = _ref7.mark,\n      checkBarAreaWithZero = _ref7.checkBarAreaWithoutZero;\n  return function () {\n    var mainChannel = getMainRangeChannel(channel);\n    var definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n\n    if (definedValueOrConfig !== undefined) {\n      return vgValueRef(channel, definedValueOrConfig);\n    }\n\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        var scaleType = scale.get('type');\n\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              scaleType: scaleType\n            }));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              zeroFalse: scale.explicit.zero === false\n            }));\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return mainChannel === 'x' ? {\n          value: 0\n        } : {\n          field: {\n            group: 'height'\n          }\n        };\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {\n          field: {\n            group: 'width'\n          }\n        } : {\n          value: 0\n        };\n      }\n    }\n\n    return defaultRef;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}