{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { MAIN } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys } from '../../util';\nimport { getMarkConfig, getStyles, sortParams } from '../common';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nvar markCompiler = {\n  area: area,\n  bar: bar,\n  circle: circle,\n  geoshape: geoshape,\n  image: image,\n  line: line,\n  point: point,\n  rect: rect,\n  rule: rule,\n  square: square,\n  text: text,\n  tick: tick,\n  trail: trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\nvar FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model) {\n  var details = pathGroupingFields(model.mark, model.encoding);\n  var pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details\n        }\n      },\n      encode: {\n        update: {\n          width: {\n            field: {\n              group: 'width'\n            }\n          },\n          height: {\n            field: {\n              group: 'height'\n            }\n          }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model) {\n  var encoding = model.encoding,\n      stack = model.stack,\n      mark = model.mark,\n      markDef = model.markDef,\n      config = model.config;\n  var order = encoding.order;\n\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(markDef.order) || isNullOrFalse(getMarkConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    var dimensionChannelDef = encoding[dimensionChannel];\n\n    if (isFieldDef(dimensionChannelDef)) {\n      var s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        var fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n}\n\nfunction getMarkGroups(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fromPrefix: ''\n  };\n  var mark = model.mark;\n  var clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  var style = getStyles(model.markDef);\n  var key = model.encoding.key;\n  var sort = getSort(model);\n  var interactive = interactiveFlag(model);\n  var postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style: style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort: sort\n  } : {}), interactive ? interactive : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(MAIN)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\n\n\nfunction scaleClip(model) {\n  var xScale = model.getScaleComponent('x');\n  var yScale = model.getScaleComponent('y');\n  return xScale && xScale.get('selectionExtent') || yScale && yScale.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\n\n\nfunction projectionClip(model) {\n  var projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\n\n\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  var unitCount = keys(model.component.selection).length;\n  var parentCount = unitCount;\n  var parent = model.parent;\n\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n\n  return parentCount ? {\n    interactive: unitCount > 0\n  } : null;\n}","map":null,"metadata":{},"sourceType":"module"}